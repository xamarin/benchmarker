# -*- python -*-
# vim: syntax=python
import os, sys, itertools
from twisted.python import log

###### MODULE RELOAD MAGIC (cf. http://sourceforge.net/p/buildbot/mailman/message/32915320/ )
# this will reload all python files in the 'SCANDIR' directories relative to 'MASTERDIR' (do not use . or ..)
SCANDIR = [''] # KEEP UP TO DATE

MASTERDIR = os.path.abspath(os.path.dirname(__file__))
FILES = filter(lambda f: f.endswith(".py") and not '__init__' in f, itertools.chain(*map(lambda s: map(lambda f: os.path.join(s, f), os.listdir(os.path.join(MASTERDIR, s))), SCANDIR)))
for filename in FILES:
    modname = filename[:-3].replace(os.sep, '.')
    if sys.modules.has_key(modname):
        oldModule = sys.modules.pop(modname)
        oldId = 1
        oldKey = None
        while True:
            oldKey = modname + "-" + str(oldId)
            if sys.modules.has_key(oldKey):
                oldId += 1
            else:
                break
        sys.modules[oldKey] = oldModule
        log.msg("Reloading " + modname + ", old module renamed as " + oldKey)


from buildbot.process.properties import Interpolate
from buildbot.buildslave import BuildSlave
from buildbot.status import html
from buildbot.status.results import SUCCESS
from buildbot.steps.shell import ShellCommand
from buildbot.steps.transfer import FileDownload

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler

from buildbot.config import BuilderConfig

from monosteps import ParsingShellCommand, PutPropertiesStep
from monofactory import DebianMonoBuildFactory

from jenkinspoller import BuildURLToPropertyStep, FetchJenkinsBuildDetails, MonoJenkinsPoller
from constants import BUILDBOT_URL, MONOBASEURL, JENKINS_URL, PROPERTYNAME_JENKINSBUILDURL, PROPERTYNAME_JENKINSGITCOMMIT, PROPERTYNAME_MONOVERSION, PROPERTYNAME_RUNSETID, PROPERTYNAME_SKIP_BENCHS
from checkretry import CheckRetryStep

#pylint: disable=F0401
import credentials
#pylint: enable=F0401
import googleoauth2
import slack

import re
import json

# This is the dictionary that the buildmaster pays attention to
#pylint: disable=C0103
C = BuildmasterConfig = {}
#pylint: enable=C0103

ALL_REPOSITORIES = {
    r'https://github.com/xamarin/benchmarker/': 'benchmarker'
}

def codebase_generator(chdict):
    return ALL_REPOSITORIES[chdict['repository']]

def _mk_slave((hostname, pwd)):
    return BuildSlave(hostname, pwd, max_builds=1, keepalive_interval=10)

C['slaves'] = map(_mk_slave, credentials.getSlaves())
C['protocols'] = {'pb': {'port': 9989}}
C['mergeRequests'] = False
C['db'] = {'db_url' : "sqlite:///state.sqlite", }

C['change_source'] = []
C['schedulers'] = []
C['builders'] = []

# helper function to create change_source, schedulers and builder for a
# specific slave/platform/config_name configuration
def _mk_benchmarker(slavename, platform, config_name):
    builder_name = platform + '_' + slavename + '_' + config_name

    fake_repo_url = JENKINS_URL + r'/view/All/job/build-package-dpkg-mono/%s/%s/%s' % (platform, slavename, config_name)
    fake_repo_name = 'mono-jenkins-%s-%s-%s' % (platform, slavename, config_name)
    ALL_REPOSITORIES[fake_repo_url] = fake_repo_name

    C['change_source'].append(
        MonoJenkinsPoller(
            MONOBASEURL, fake_repo_url,
            platform, slavename,
            config_name, pollInterval=600
        )
    )

    codebases = {
        'benchmarker': {
            'repository': 'https://github.com/xamarin/benchmarker/',
            'branch': None,
            'revision': 'HEAD'},
        fake_repo_name: {'repository': fake_repo_url}
    }

    C['schedulers'].append(
        SingleBranchScheduler(
            name=builder_name + '_jenkins_sched',
            branch=None,
            codebases=codebases,
            treeStableTimer=None,
            builderNames=[builder_name]
        )
    )

    C['schedulers'].append(
        ForceScheduler(
            name=builder_name + '_force_sched',
            codebases=codebases,
            builderNames=[builder_name]
        )
    )

    def _read_config_file():
        with open('../configs/' + config_name + '.conf') as fhandle:
            return json.load(fhandle)

    disable_turbo = _read_config_file().get('DisableTurbo', False)

    factory = DebianMonoBuildFactory()
    factory.addStep(PutPropertiesStep({'platform': platform, 'config_name': config_name}))

    # transform some properties from the change source
    factory.addStep(BuildURLToPropertyStep(MONOBASEURL))

    if disable_turbo:
        factory.addStep(
            ShellCommand(
                name="disableintelturbo",
                command=['bash', '-c', '(echo 0 | sudo /usr/bin/tee /sys/devices/system/cpu/cpufreq/boost) || (echo "only supported on Intel CPUs" && exit 1)'],
                haltOnFailure=True
            )
        )

        class AlwaysSuccessShellCommand(ShellCommand):
            def __init__(self, *args, **kwargs):
                ShellCommand.__init__(self, *args, **kwargs)

            def finished(self, _):
                ShellCommand.finished(self, SUCCESS)

        # cf. http://pm-blog.yarda.eu/2011/10/deeper-c-states-and-increased-latency.html
        # by keeping the file descriptor alive, we make sure that this setting is used.
        # after closing the file descriptor, the old setting will be restored by the
        # kernel module.
        factory.addStep(FileDownload('forcec0state.sh', 'forcec0state.sh'))

        # `setsid' is used in to escape the process group, otherwise it will be
        # killed by the timeout logic of AlwaysSuccessShellCommand. since the
        # parent process gets killed by it, we always force it to be
        # successful. (I wish there would be a nicer way to do it).
        factory.addStep(AlwaysSuccessShellCommand(
            name="forceC0state",
            command=['sudo', '-b', '/bin/bash', '-c', 'setsid bash -x ./forcec0state.sh'],
            haltOnFailure=False,
            flunkOnFailure=False,
            timeout=5
        ))

    factory.clone_benchmarker()
    # checkout benchmarker repo on the master and build it on the master.
    # the idea is that this minimizes dependencies (such as nuget or xbuild) on the slaves.
    factory.benchmarker_on_master()

    # upload build artifacts from master to slave
    factory.upload_benchmarker()

    tmp_dir = lambda e: 'tmp' + str(e)
    factory.addStep(ShellCommand(name='rm temp dir', command=['sudo', 'rm', '-rf', tmp_dir('')]))
    factory.addStep(ShellCommand(name='mkdir temp dir', command=['mkdir', '-p', tmp_dir('')]))
    # get URLs of jenkins build artifacts
    factory.addStep(
        FetchJenkinsBuildDetails(
            name='fetch jenkins build',
            description='fetch URLs from Jenkins'
        )
    )

    # download debian packages
    for prop_name, target_file in [('deb_common_url', 'common.deb'), ('deb_asm_url', 'assemblies.deb'), ('deb_bin_url', 'mono.deb')]:
        factory.addStep(ShellCommand(
            name='download ' + target_file,
            description='downloading ' + target_file + ' from jenkins',
            command=['wget', '-O', tmp_dir('/' + target_file), Interpolate('%(prop:' + prop_name + ')s')],
            haltOnFailure=True
        ))

    # install debian packages
    install_root = lambda e: 'installation' + str(e)
    factory.addStep(ShellCommand(name='envprep0', command=['sudo', 'rm', '-rf', install_root('')]))
    factory.addStep(ShellCommand(name='envprep1', command=['mkdir', '-p', install_root('/var/lib/')]))
    factory.addStep(ShellCommand(name='envprep2', command=['sudo', '/bin/cp', '-a', '/var/lib/dpkg', install_root('/var/lib/')]))
    for package in ['common.deb', 'assemblies.deb', 'mono.deb']:
        factory.addStep(
            ShellCommand(
                name='install ' + package,
                description='install ' + package,
                command=['sudo', '/usr/bin/dpkg', '--root=' + install_root(''), '--unpack', tmp_dir('/' + package)],
                haltOnFailure=True
            )
        )

    # get mono version
    factory.addStep(
        ParsingShellCommand(
            name='getMonoVersion',
            parse_rules={PROPERTYNAME_MONOVERSION: re.compile(r'(?P<' + PROPERTYNAME_MONOVERSION + r'>[a-zA-Z0-9\.\-\+]+)')},
            command=['ls', install_root('/opt')]
        )
    )

    factory.addStep(
        ShellCommand(
            name='printMonoVersion',
            command=['echo', Interpolate("%(prop:" + PROPERTYNAME_MONOVERSION + ")s")]
        )
    )

    factory.addStep(CheckRetryStep())

    def _guard_runsetid_gen(step):
        return not step.build.getProperties().has_key(PROPERTYNAME_RUNSETID)

    # TOOD: make it conditional (force scheduler can provide runsetid as well)
    factory.addStep(
        ParsingShellCommand(
            name='create RunSetId',
            parse_rules={PROPERTYNAME_RUNSETID: re.compile(r'"runSetId"\s*:\s*"(?P<' + PROPERTYNAME_RUNSETID + r'>\w+)"')},
            command=['mono',
                     'tools/compare.exe',
                     '--create-run-set',
                     '--build-url', Interpolate('%(prop:' + PROPERTYNAME_JENKINSBUILDURL + ')s'),
                     '--root', Interpolate('../build/' + install_root('/opt/%(prop:' + PROPERTYNAME_MONOVERSION + ')s')),
                     '--commit', Interpolate('%(prop:' + PROPERTYNAME_JENKINSGITCOMMIT + ')s'),
                     'tests/',
                     'benchmarks/',
                     'machines/',
                     Interpolate('configs/%(prop:config_name)s.conf')
                    ],
            workdir='benchmarker',
            doStepIf=_guard_runsetid_gen,
            haltOnFailure=True
        )
    )

    factory.addStep(
        ShellCommand(
            name='print RunSetId',
            command=['echo', Interpolate("%(prop:" + PROPERTYNAME_RUNSETID + ")s")]
        )
    )

    # TODO: get at 'runtime', via compare.exe tool
    benchmarks_list = ['ahcbench', 'bh', 'binarytree', 'bisort', 'compress', 'couchbase', 'db',
                       'euler', 'except', 'fsharp', 'grandetracer', 'graph4', 'graph8', 'hash2',
                       'health', 'ipy', 'ironjs-sunspider', 'ironjs-v8', 'lcscbench', 'lists',
                       'mandelbrot', 'msbiology', 'n-body', 'objinst', 'onelist', 'perimeter',
                       'raytracer2', 'raytracer3', 'roslyn', 'scimark-fft', 'scimark-lu', 'scimark-mc',
                       'scimark-mm', 'scimark-sor', 'sharpchess', 'sharpsatbench', 'specraytracer',
                       'strcat'
                      ]

    def gen_guard_benchmark_run(benchmark):
        def _guard_benchmark_run(benchmark, step):
            if not step.build.getProperties().has_key(PROPERTYNAME_SKIP_BENCHS):
                return True
            executed_benchmarks = step.build.getProperties().getProperty(PROPERTYNAME_SKIP_BENCHS)
            if executed_benchmarks is None:
                return True
            assert isinstance(executed_benchmarks, list), "it is: " + str(executed_benchmarks)
            return benchmark not in executed_benchmarks
        # scopes in python are stupid.
        return lambda s: _guard_benchmark_run(benchmark, s)

    for benchmark_name in benchmarks_list:
        if 'arm' in platform:
            # let the device cool down a bit? (wtf)
            factory.addStep(ShellCommand(name="sleep", command=["bash", "-c", "sensors; sleep 1m; sensors"]))
        factory.addStep(
            ShellCommand(
                name=benchmark_name,
                description="benchmark " + benchmark_name,
                command=['mono',
                         'tools/compare.exe',
                         '--benchmarks', benchmark_name,
                         '--log-url', Interpolate(BUILDBOT_URL + '/builders/%(prop:buildername)s/builds/%(prop:buildnumber)s'),
                         '--build-url', Interpolate('%(prop:' + PROPERTYNAME_JENKINSBUILDURL + ')s'),
                         '--root', Interpolate('../build/' + install_root('/opt/%(prop:' + PROPERTYNAME_MONOVERSION + ')s')),
                         '--commit', Interpolate('%(prop:' + PROPERTYNAME_JENKINSGITCOMMIT + ')s'),
                         '--run-set-id', Interpolate('%(prop:' + PROPERTYNAME_RUNSETID + ')s'),
                         'tests/',
                         'benchmarks/',
                         'machines/',
                         Interpolate('configs/%(prop:config_name)s.conf')
                        ],
                timeout=45*60,
                doStepIf=gen_guard_benchmark_run(benchmark_name),
                workdir='benchmarker'
            )
        )

    # cleanup turbo settings
    if disable_turbo:
        factory.addStep(
            ShellCommand(
                name="enableturbo",
                command=['bash', '-c', '(echo 1 | sudo /usr/bin/tee /sys/devices/system/cpu/cpufreq/boost) || (echo "only supported on Intel CPUs" && exit 1)'],
                haltOnFailure=True,
                alwaysRun=True
            )
        )
        factory.addStep(
            ShellCommand(
                name="releaseNoTurboFP",
                command=['bash', '-c', 'sudo /bin/kill `sudo /usr/bin/lsof -t /dev/cpu_dma_latency`'],
                haltOnFailure=True,
                alwaysRun=True
            )
        )

    # cleanup working dir
    factory.wipe()

    C['builders'].append(
        BuilderConfig(
            name=builder_name,
            slavenames=[slavename],
            factory=factory
        )
    )

def create_slaves():
    for (slavename, _) in credentials.getSlaves():
        if slavename == 'bernhard-linux-vbox':
            _mk_benchmarker(slavename, 'debian-amd64', 'auto-sgen')
        if slavename == 'benchmarker':
            _mk_benchmarker(slavename, 'debian-amd64', 'auto-sgen-noturbo')
        if slavename == 'utilite-desktop':
            _mk_benchmarker(slavename, 'debian-armhf', 'auto-sgen')

create_slaves()

####### STATUS TARGETS
C['status'] = []
AUTHZ_CFG = googleoauth2.GoogleOAuth2AuthZ(
    url='https://accounts.google.com/o/oauth2/auth',
    client_id=credentials.getGoogleAPIKeyClientID(),
    client_secret=credentials.getGoogleAPIKeyClientSecret(),
    root_uri=BUILDBOT_URL,
    all=['view'],
    authenticated=['gracefulShutdown', 'forceBuild', 'pingBuilder', 'stopBuild', 'cancelPendingBuild']
)

C['status'].append(html.WebStatus(http_port=8010, authz=AUTHZ_CFG))
C['status'].append(slack.StatusPush(
    credentials.getSlackAPIKey(),
    '#performance-bot',
    localhost_replace=BUILDBOT_URL
))


####### PROJECT IDENTITY
C['title'] = "Mono Performance Bots"
C['titleURL'] = "https://github.com/mono/mono"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

C['codebaseGenerator'] = codebase_generator
C['buildbotURL'] = "http://localhost:8010/"
